

**EGE UNIVERSITY**

**FACULTY OF ENGINEERING**

**COMPUTER ENGINEERING DEPARTMENT**

**PROGRAMMING LANGUAGES**

**2020–2021 SPRING SEMESTER**

**PROJECT-2 REPORT**

**INTERPRETER FOR THE BIGADD LANGUAGE**

**DELIVERY DATE**

08/07/2021

**PREPARED BY**

05190000747, Andres Arturo Rodriguez Calderon

05190000853, Adil Özdemir

05190000105, Recep Tayyip Ünlütürk

05190000107, Şükriye Züleyha Alkan





Contents

[1)](#br3)[ ](#br3)[INTRODUCTION](#br3)[ ](#br3)[...................................................................................................................................](#br3)[ ](#br3)[2](#br3)

[2)](#br4)[ ](#br4)[PARSER](#br4)[ ](#br4)[&](#br4)[ ](#br4)[INTERPRETER......................................................................................................................](#br4)[ ](#br4)[3](#br4)

[2.a](#br4)[ ](#br4)[Design](#br4)[ ](#br4)[of](#br4)[ ](#br4)[The](#br4)[ ](#br4)[Algorithm................................................................................................................](#br4)[ ](#br4)[3](#br4)

[2.a.1](#br8)[ ](#br8)[Code........................................................................................................................................](#br8)[ ](#br8)[7](#br8)

[2.b](#br18)[ ](#br18)[Memory](#br18)[ ](#br18)[.......................................................................................................................................](#br18)[ ](#br18)[17](#br18)

[2.b.1](#br18)[ ](#br18)[Code......................................................................................................................................](#br18)[ ](#br18)[17](#br18)

[2.c](#br20)[ ](#br20)[Outs..............................................................................................................................................](#br20)[ ](#br20)[19](#br20)

[2.c.1](#br20)[ ](#br20)[Code......................................................................................................................................](#br20)[ ](#br20)[19](#br20)

[2.e](#br22)[ ](#br22)[Arithmetic](#br22)[ ](#br22)[Operations.................................................................................................................](#br22)[ ](#br22)[21](#br22)

[2.e.1](#br23)[ ](#br23)[Code......................................................................................................................................](#br23)[ ](#br23)[22](#br23)

[2.f](#br30)[ ](#br30)[Execution](#br30)[ ](#br30)[of](#br30)[ ](#br30)[Blocks](#br30)[ ](#br30)[......................................................................................................................](#br30)[ ](#br30)[29](#br30)

[2.f.1](#br31)[ ](#br31)[Code](#br31)[ ](#br31)[......................................................................................................................................](#br31)[ ](#br31)[30](#br31)

[3)](#br41)[ ](#br41)[USER](#br41)[ ](#br41)[INPUTS](#br41)[ ](#br41)[&](#br41)[ ](#br41)[INTERPRETER](#br41)[ ](#br41)[IMPLEMENTATION............................................................................](#br41)[ ](#br41)[40](#br41)

[3.a](#br41)[ ](#br41)[Code.............................................................................................................................................](#br41)[ ](#br41)[40](#br41)

[4)](#br43)[ ](#br43)[Test](#br43)[ ](#br43)[Screenshots](#br43)[ ](#br43)[...............................................................................................................................](#br43)[ ](#br43)[42](#br43)

[4.a](#br43)[ ](#br43)[Finding](#br43)[ ](#br43)[the](#br43)[ ](#br43)[nth](#br43)[ ](#br43)[Fibonacci](#br43)[ ](#br43)[of](#br43)[ ](#br43)[101](#br43)[ ](#br43)[Digits](#br43)[ ](#br43)[.......................................................................................](#br43)[ ](#br43)[42](#br43)

[4.b](#br44)[ ](#br44)[Finding](#br44)[ ](#br44)[The](#br44)[ ](#br44)[Sum](#br44)[ ](#br44)[of](#br44)[ ](#br44)[The](#br44)[ ](#br44)[Consecutive](#br44)[ ](#br44)[Numbers](#br44)[ ](#br44)[Squared](#br44)[ ](#br44)[............................................................](#br44)[ ](#br44)[43](#br44)

[4.c](#br45)[ ](#br45)[Drawing](#br45)[ ](#br45)[a](#br45)[ ](#br45)[Right-Angled](#br45)[ ](#br45)[Triangle](#br45)[ ](#br45)[.................................................................................................](#br45)[ ](#br45)[44](#br45)

[4.d](#br46)[ ](#br46)[Syntax](#br46)[ ](#br46)[Error](#br46)[ ](#br46)[Example](#br46)[ ](#br46)[1](#br46)[ ](#br46)[...............................................................................................................](#br46)[ ](#br46)[45](#br46)

[4.e](#br46)[ ](#br46)[Syntax](#br46)[ ](#br46)[Error](#br46)[ ](#br46)[Example](#br46)[ ](#br46)[2................................................................................................................](#br46)[ ](#br46)[45](#br46)

1





\1) INTRODUCTION

For the implementation of the interpreter the IDE Apache NetBeans 12.2 and [Cygwin](https://www.cygwin.com/)[ ](https://www.cygwin.com/)have been

used.

As two project groups have come together, there have been problems in being able to work and

execute the code due to differences in compilers, that is why it has been obtained by working

temporarily during the project with an online compiler. We leave the lin[k](https://replit.com/@andresrodrigu/PL#main.c)[ ](https://replit.com/@andresrodrigu/PL#main.c)[here](https://replit.com/@andresrodrigu/PL#main.c)[ ](https://replit.com/@andresrodrigu/PL#main.c)in case execution

problems arise. To be able to see the documents that we use in the code production you must click

on the "code" tab.

It has stopped writing the .xl extension documents in order to make an interpreter as realistic as

possible, having to execute each line of code individually (as long as it is correct) there have been

problems with writing .xl documents in the loops, also it has not wanted to interpret the results of

the .xl documents because that would rather simulate a compiler (since we would be reading the

entire document first). As nothing has been said about writing .xl documents in this project it has

been decided to stop doing it.

This report will go by the order in which the algorithms were designed, the cited part of code will be

shown in each section.

2





\2) PARSER & INTERPRETER

2.a Design of The Algorithm

For the solution of the parser problem, it has been decided to implement the most obvious solution,

create states where one can be found and be guided by them. In order to implement this, it has been

decided to make FSMs of any state in which we may find ourselves.

Note: all the different situations that could occur (wrong situations) have not been shown in the

FSMs due to their density. Any input other than those shown that can occur in all states except the

initial one will be counted as reject.

3





4





5





Also, despite the fact that we are talking about a parser, let us remember that it will play a very

important role with the interpreter, because the interpreter will execute each correct line of code

that it sees.

Having said this we are aware that until a line of code does not finalize it will not be able to be

executed, these make us think that it will be necessary to save each element read, be it strings,

number values, etc...

Having said this, it has been thought to use two global variables, one of which will save the numerical

values read and the other the variable name, the reason for this is because if we remember the add,

sub and loop instructions technically use one variable and one numerical value.

We will also need a structure such that it can save the elements that are going to be printed,

remember that there are two types of elements that can be printed, which are the structure that we

created for the strings and character arrays.

We will also need a memory that stores all the variables declared by the user.

Finally, I would like to emphasize the issue of loops, in the last finite state machine shown it can be

clearly seen that loops will be a delicate situation, either due to the situations they contain or

because when designing an interpreter each line must be executed of code one by one, so from now

on we can guess that we will need two functions, one that will execute the lines of code that the

main block contains and the other that executes a loop block.

For the errors, an encoding table will be made which is helped by the FSMs shown and the encoding

of the stored word that could already be seen in the previous project, so the user will be notified of

the most exact errors possible.

Having said all this, we already know that all the functions that have to do with variables will also

have to be done (such as moving a value, adding, subtracting, etc...), these functions and the output

functions only and will only be executed when a line of code read has been validated thanks to the

FSMs, basically the required function will be put into operation when an end of line has been

reached.

6





2.a.1 Code

/\* ------------------------------- PARSER --------------------------------------

In order to analyze all the tokens correctly taking into account the grammar of

the code, it has been decided to partition this work.

First individual FSMs have been drawn simulating each possible action

(loops, variable declarations, etc ...). Having done so, it has been decided

to design a state table and thus be able to guide us in each moment of what

state we are in and to which we should and next.

For the reject states, it has been decided to design a table error, it will

contain the possible errors that we can find and will be used in the future to

send messages to the user via the console, determining the specific error

found.

In order to implement all this, it has been decided to encode the stored tokens,

so at all times it will be known if a keyword, a valid variable name, an

invalid, etc ...

Finally, to know when we have to analyze a situation, pause characters have

been determined (types of space, periods, commas, etc.). We know that when we

get to the reading of this type of character, a token should normally have

already been saved (most of the time). The double quotation mark and curly

bracket (opener and closer) characters have been excluded from our pause

characters. The reason for this is due to the intersection between the two.

\|------------------------------------------------------------------|

|

State Table

|

\|------------------------------------------------------------------|

| State initial

| State int

| State variable name being declared

| State move

| State value that is being moved

| State to (move)

| State variable to which a value is being moved

| State loop

| State loop n times value

| State times

| State out

| State list element

| State add

| State increase or decrease value (sum)

| State to (add)

| State variable being increased or decreased (sum)

| State sub

| State increase or decrease value (subtraction)

|

|

|

|

|

|

|

|

|

|

|

|

|

|

|

|

|

|

|

0

1

2

3

4

5

6

7

8

|

|

|

|

|

|

|

|

|

|

|

|

|

|

|

|

|

|

|

|

9

10

11

12

13

14

15

16

17

18

| State from

| State variable being increased or decreased (subtraction) | 19

\|------------------------------------------------------------------|

\|----------------------------------------------------------|

|

Encode Values

|

\|----------------------------------------------------------|

| Keyword Int

| Valid Variable Name

| Invalid Variable Name (bigger then 20 characters)

| Invalid Variable Name (invalid name)

| Keyword Move

|

|

|

|

|

|

0 |

1 |

2 |

3 |

4 |

5 |

| Valid IntConstant

| Invalid IntConstant (contains more than 100 digits) | 6 |

| Invalid IntConstant (example : -, 5-5, 5--53)

| Keyword To

| Keyword Loop

|

|

|

7 |

8 |

9 |

| Keyword Times

| 10 |

7





| Keyword Out

| Keyword Newline

| Keyword Add

| Keyword Sub

| Keyword From

| Valid String

| Empty

| 11 |

| 12 |

| 13 |

| 14 |

| 15 |

| 16 |

| 17 |

\|----------------------------------------------------------|

\|-----------------------------------------------------------------------------|

|

Error Codes

\|-----------------------------------------------------------------------------|

Line number>0 Line number**<0**

**|---------------------------------------|-------------------------------------|**

|

|

|

**|**

**| Invalid statement**

**| 0 | Square/curly bracket or double | 0 |**

**| Invalid variable (length)**

**| Invalid variable (name)**

**| Invalid variable declaration**

**| Invalid value assigment**

**| Use of undeclared variable**

**| 1 | quotation mark incomplete**

**| 2 |**

**| 3 |**

**| 4 | End of line not found**

**| 5 |**

**| |**

**| |**

**| |**

**| 1 |**

**| |**

**| Invalid integer (decimal length) | 6 |**

**|----------| |**

**| Invalid integer**

**| 7 | No .ba file**

**| x>**1 | x**<0**

**|**

**| Invalid loop**

**| Invalid output**

**| Invalid sum**

**| Invalid substraction**

**| Unrecognized character**

**| Invalid token found**

**| Operation exceeds 100 digits**

**| 8 |**

**| 9 |**

**| 10 |**

**| 11 |**

**| 12 |**

**| 13 |**

**| 15 |**

**|--------------|**

**|**

**|**

**|**

**|**

**|**

**|**

**|---------------------------------------|-------------------------------------**\*/

void **alertError**(int error\_code, int line\_number)

{

printf(**"\033**[0;31m**"**); //Set the text to the color red

if(line\_number>0)

{

if(error\_code==0)

printf(**"**Invalid statement**"**);

else if(error\_code==1)

printf(**"**Variables can't be bigger then 20 characters, **"**

**"**invalid variable declaration statement**"**);

else if(error\_code==2)

printf(**"**Use of invalid variable name, invalid variable declaration **"**

**"**statement**"**);

else if(error\_code==3)

printf(**"**Invalid variable declaration statement**"**);

else if(error\_code==4)

printf(**"**Invalid value assigment statement**"**);

else if(error\_code==5)

printf(**"**Invalid statement, an undeclared variable is being used**"**);

else if(error\_code==6)

printf(**"**Invalid use of integer, the declared integer passes **"**

**"**100 decimal places**"**);

else if(error\_code==7)

printf(**"**Invalid integer**"**);

else if(error\_code==8)

printf(**"**Invalid loop statement**"**);

else if(error\_code==9)

8





printf(**"**Invalid output statement**"**);

else if(error\_code==10)

printf(**"**Invalid sum statement**"**);

else if (error\_code==11)

printf(**"**Invalid subtraction statement**"**);

else if (error\_code==12)

printf(**"**Unrecognized character found**"**);

else if (error\_code==13)

printf(**"**Invalid token found**"**);

else if(error\_code==14)

printf(**"**Unrecognized character detected in code**"**);

else if(error\_code==15)

printf(**"**The result of the arithmetic operation exceeds 100 digits**"**);

printf(**"** at line %d...**\n"**, line\_number);

}

else

{

if(error\_code==0)

printf(**"**A big lexeme is just left open...**\n"**);

else if(error\_code==1)

printf(**"**Statement not finalized, end of line character **"**

**"**forgotten...**\n"**);

else

printf(**"**There is no .ba file with the name entered in the root **"**

**"**folder...**\n"**);

}

printf(**"\033**[0m**"**); //Resets the text to default color

printf(**"\n**Press Any Key to end the program**\n"**);

getchar();

exit(0);

}

void **alertErrorPerState**(int line\_number, int \*state)

{

if(\*state==0)

alertError(0, line\_number);

else if(\*state==2 || \*state==1) //Invalid variable declaration.

alertError(3, line\_number);

else if(3<=\*state && 6>=\*state) //Invalid value assigment.

alertError(4, line\_number);

else if(7<=\*state && 9>=\*state) //Invalid loop statement.

alertError(8, line\_number);

else if(\*state==11 || \*state==10) //Invalid out.

alertError(9, line\_number);

else if(12<=\*state && 15>=\*state) //Invalid sum statement.

alertError(10, line\_number);

else //Invalid subtraction statement.

alertError(11, line\_number);

}

void **typeOfSpacePositionAndTransitionMaker**(int \*previous\_state,

int saved\_string\_code, char \*character\_accumulation, int line\_number)

9





{

/\* This function is the one that will simulate state transitions,

normally it should be used whenever a type of space is being read, but also

to avoid repeating more code, it will be used again when a comma, period or

some other similar character is being read. The reason for this is because

when a point is read, we could have accumulated characters that are our

next state. But we could see this function directly as the one that

fulfills the state transitions. \*/

if(saved\_string\_code==17) //Empty.

return;

//Start state or loop start line state.

if(\*previous\_state==0 || \*previous\_state==9)

{

if(saved\_string\_code==0) //Saved string := int

\*previous\_state=1; //Previous state := int

else if(saved\_string\_code==4) //Saved string := move

\*previous\_state=3; //Previous state := move

else if(saved\_string\_code==9) //Saved string := loop

\*previous\_state=7; //Previous state := loop

else if(saved\_string\_code==11) //Saved string := out

\*previous\_state=10; //Previous state := out

else if(saved\_string\_code==13) //Saved string := add

\*previous\_state=12; //Previous state := add

else if(saved\_string\_code==14) //Saved string := sub

\*previous\_state=16; //Previous state := sub

else

alertError(0, line\_number);

}

else if(\*previous\_state==1) //int

{

//The saved string is a valid variable name.

if(saved\_string\_code==1)

{

\*previous\_state=2; //Previous state := variable name being declared.

variable\_name=malloc(21);

strcpy(variable\_name, character\_accumulation);

}

//The saved string is an invalid variable name

//(bigger then 20 characters).

else if(saved\_string\_code==2)

alertError(1, line\_number);

//The saved string is an invalid variable name.

else if(saved\_string\_code==3)

alertError(2, line\_number);

//Output invalid variable declaration message.

else

alertError(3, line\_number);

}

else if(\*previous\_state==3) //Previous state := move

{

//The saved string is a valid intConstant .

if(saved\_string\_code==5 )

{

\*previous\_state=4; //Previous state := value that is being moved

natural\_number=malloc(103);

10





strcpy(natural\_number, character\_accumulation);

}

//The saved string is an invalid intConstant (example : -).

else if(saved\_string\_code==7)

alertError(7, line\_number);

//The saved string is a valid variable name.

else if(saved\_string\_code==1)

{

if(variableExists(memory, character\_accumulation))

{

\*previous\_state=4;

natural\_number=malloc(103);

strcpy(natural\_number,

obtainVariableValue(character\_accumulation));

}

else //Output use of undeclared variable message.

alertError(5, line\_number);

}

else //Output invalid value assigment message.

alertError(4, line\_number);

}

else if(\*previous\_state==4) //Previous state := value that is being moved

{

if (saved\_string\_code==8) //The saved string is the keyword to.

\*previous\_state=5; //Previous state := to (move)

else //Output invalid value assigment message.

alertError(4, line\_number);

}

else if(\*previous\_state==5) //Previous state := to (move)

{

if (saved\_string\_code==1) //Saved string := Valid variable name

{

//Previous state := variable to which a value is being moved

if(variableExists(memory, character\_accumulation))

{

\*previous\_state=6;

variable\_name=malloc(21);

strcpy(variable\_name, character\_accumulation);

}

else //Output use of undeclared variable message.

alertError(5, line\_number);

}

else //Output invalid value assigment message.

alertError(4, line\_number);

}

else if(\*previous\_state==12) //Previous state := add

{

//Saved string := Valid intConstant

if (saved\_string\_code==5)

{

\*previous\_state=13; //Previous state := increase or decrease

//value (sum)

natural\_number=malloc(103);

strcpy(natural\_number, character\_accumulation);

}

//The saved string is an invalid intConstant (example : -).

else if(saved\_string\_code==7)

11





alertError(7, line\_number);

else if(saved\_string\_code==1) //Saved string := Valid variable name

{

if(variableExists(memory, character\_accumulation))

{

\*previous\_state=13; //Previous state := increase or decrease

//

natural\_number=malloc(103);

strcpy(natural\_number,

value (sum)

obtainVariableValue(character\_accumulation));

}

else //Output use of undeclared variable message.

alertError(5, line\_number);

}

else //Output invalid sum statement message.

alertError(10, line\_number);

}

else if(\*previous\_state==13) //Previous state := increase or decrease

//value (sum)

{

if (saved\_string\_code==8) //Saved string := to

\*previous\_state=14; //Previous state := to (add)

else //Output invalid sum statement message.

alertError(10, line\_number);

}

else if(\*previous\_state==14) //Previous state := to (add)

{

if(saved\_string\_code==1) //Saved string := Valid variable name

{

if(variableExists(memory, character\_accumulation))

{

\*previous\_state=15;

variable\_name=malloc(21);

strcpy(variable\_name, character\_accumulation);

}

else

alertError(2, line\_number);

}

else //Output invalid sum statement message.

alertError(10, line\_number);

}

else if(\*previous\_state==16) //Previous state := sub

{

//Saved string := Valid intConstant

if (saved\_string\_code==5)

{

\*previous\_state=17; //Previous state := increase or decrease

// value (subtraction)

natural\_number=malloc(103);

strcpy(natural\_number, character\_accumulation);

}

//Saved string := invalid intConstant (example: --)

else if (saved\_string\_code==7)

alertError(7, line\_number);

else if(saved\_string\_code==1) //Saved string := Valid variable name

{

if(variableExists(memory, character\_accumulation))

12





{

\*previous\_state=17; //Previous state := increase or decrease

//value (subtraction)

natural\_number=malloc(103);

strcpy(natural\_number,

obtainVariableValue(character\_accumulation));

}

else

alertError(5, line\_number);

}

else //Output invalid subtraction statement message.

alertError(11, line\_number);

}

else if(\*previous\_state==17) //Previous state := increase or decrease

//value (subtraction)

{

if (saved\_string\_code==15) //Saved string := from

\*previous\_state=18; //Previous state := from

else //Output invalid subtraction statement message.

alertError(11, line\_number);

}

else if(\*previous\_state==18) //Previous state := from

{

if(saved\_string\_code==1) //Saved string := Valid variable name

{

if(variableExists(memory, character\_accumulation))

{

\*previous\_state=19;

variable\_name=malloc(21);

strcpy(variable\_name, character\_accumulation);

}

else

alertError(2, line\_number);

}

else //Output invalid subtraction statement message.

alertError(11, line\_number);

}

else if(\*previous\_state==7) //Previous state := loop

{

//Saved string := Valid intConstant

if (saved\_string\_code==5 )

{

\*previous\_state=8; //Previous state := loop n times value

variable\_name=NULL;

natural\_number=malloc(103);

strcpy(natural\_number, character\_accumulation);

}

//Saved string := invalid intConstant (example: --)

else if (saved\_string\_code==7)

alertError(7, line\_number);

else if(saved\_string\_code==1) //Saved string := Valid variable name

{

if(variableExists(memory, character\_accumulation))

{

\*previous\_state=8; //Previous state := loop n times value

natural\_number=NULL;

variable\_name=malloc(21);

strcpy(variable\_name, character\_accumulation);

13





}

else

alertError(5, line\_number);

}

else //Output invalid loop statement message.

alertError(8, line\_number);

}

else if(\*previous\_state==8) //Previous state := loop n times value

{

if (saved\_string\_code==10) //Saved string := times

\*previous\_state=9; //Previous state := times

else //Output invalid loop statement message.

alertError(8, line\_number);

}

else if(\*previous\_state==10 || \*previous\_state==11) //out

{

if(saved\_string\_code==1)//Saved string := Valid variable name

{

if(variableExists(memory, character\_accumulation))

{

\*previous\_state=11; //outlist element

addVariableToOutList(character\_accumulation, &out\_list);

}

else //Output use of undeclared variable message.

alertError(5, line\_number);

}

else if(saved\_string\_code==16) //String

{

\*previous\_state=11;

addStringElementToOutList(&string, &out\_list);

}

else if(saved\_string\_code==5) //valid integer

{

\*previous\_state=11;

addCharArrayToOutList(character\_accumulation, &out\_list);

}

else if(saved\_string\_code==12) //Newline

{

\*previous\_state=11;

addNewlineToOutList(&out\_list);

}

//Saved string := empty

else if(saved\_string\_code==17)

\*previous\_state=11;

else if(saved\_string\_code==7) //Saved string := invalid integer (--)

alertError(7, line\_number);

else

alertError(9, line\_number);

}

/\* If you get this far, we know that we are in one of the states

'variable name being declared ',

'variable to which a value is being moved',

'variable being increased or decreased (sum)' or

'variable being increased or decreased (subtraction )' and that we have

stored characters. Then, as this accumulation of characters is

invalidating the completion of those statements, a type of error message

14





will be sent to the user depending on the situation. \*/

else

alertErrorPerState(line\_number, previous\_state);

}

void **commaPosition**(int \*previous\_state, int saved\_string\_code,

char \*character\_accumulation, int line\_number)

{

typeOfSpacePositionAndTransitionMaker(previous\_state, saved\_string\_code,

character\_accumulation, line\_number);

if(\*previous\_state!=11) //if the previous state is not list element.

alertErrorPerState(line\_number, previous\_state);

}

void **dotPosition**(int \*previous\_state, int saved\_string\_code,

char \*character\_accumulation, int line\_number,

int can\_perform\_the\_operation)

{

//State transition.

typeOfSpacePositionAndTransitionMaker(previous\_state, saved\_string\_code,

character\_accumulation, line\_number);

if(\*previous\_state==2)

{

if(can\_perform\_the\_operation) //For loop.

addElement(&memory, character\_accumulation);

}

else if(\*previous\_state==6)

{

if(can\_perform\_the\_operation) //For loop.

moveValue(character\_accumulation, natural\_number);

}

else if(\*previous\_state==11)

{

if(can\_perform\_the\_operation) //For loop.

printOutList(&out\_list);

}

else if(\*previous\_state==15)

{

if(can\_perform\_the\_operation) //For loop.

sumStringIntegerToVariable(character\_accumulation, natural\_number,

line\_number);

}

else if(\*previous\_state==19)

{

if(can\_perform\_the\_operation) //For loop.

subtractStringIntegerToVariable(character\_accumulation,

natural\_number, line\_number);

}

else

{

alertErrorPerState(line\_number, previous\_state);

return;

}

/\* In the above if statement, the previous state 0 (initial) could have

been added to accept empty lines, but in the project it says

"Lines of Code: Point ('.') Is the end of line character.

Lines can contain keywords, brackets, variables and constants.",

nothing about empty lines. \*/

15





\*previous\_state=0;

}

void **endOfLine**(int \*previous\_state, int string\_flag, int comment\_flag,

int is\_square\_bracket\_open)

{

/\* Here we will check if the double quotation marks, square brackets or

curly brackets were closed, it will also be checked if an end of line was

put in the last line of code. \*/

if(string\_flag || comment\_flag || is\_square\_bracket\_open)

alertError(0, -1);

else if(\*previous\_state!=0) //No finalizado

alertError(1, -1);

}

void **stringCharacterPosition**(int \*string\_constant\_flag, int \*previous\_state,

int line\_number)

{

if (\*previous\_state==10 || \*previous\_state==11)

\*string\_constant\_flag=!(\*string\_constant\_flag);

else

alertError(0, line\_number);

}

16





2.b Memory

It has been decided to design a memory that stores the variables created by the user and thus be

able to know when the user is using a variable that he has not declared before.

For the memory design, the most obvious structure has been thought, a linked list, in which each

node stores the name of the variable, its value (which for now is not necessary but as it will be

needed in the second project from now on has done) and the next node that has to arrive.

The saved values will be of the character array type because we remember that what is read is saved

in a character array type variable, also because this language tells us that the numbers can have a

maximum of one hundred digits.

Also, from now on we want to emphasize that if the user declared an existing variable, the value

would be reset to said variable, like Python.

To increase speed, it has been decided to design the linked list in such a way that it works the other

way around, this is because normally whenever a variable is declared it is used at the time.

2.b.1 Code

/\* ----------------------- Memory for Variables---------------------------------

To control the declared variables, it has been decided to create a linked

list. In order to make controls much faster, it has been decided that the head

of the list is its tail, because normally after the declaration of variables

they are used at the moment. \*/

struct Memory

{

char \*variable\_name;

char \*value\_as\_string;

struct Memory \*behind; //Faster.

};

struct Memory \*memory; //Global variable.

void **addElement**(struct Memory \*\*list\_of\_variables, char \*variable\_name)

{

if(variableExists(\*list\_of\_variables, variable\_name))

{

//If the declared variable exists, it will be given the value 0.

char \*value0=malloc(103);

17





\*value0='**\0**'; \*(value0+1)='0'; \*((value0++)+2)='**\0**';

moveValue(variable\_name, value0);

return;

}

struct Memory \*new\_element; //Declaration of the new element.

new\_element = malloc(sizeof(struct Memory));//Allocating the requested

//memory.

new\_element->value\_as\_string=malloc(103);

\*((new\_element->value\_as\_string))='**\0**';

\*(new\_element->value\_as\_string+1)='0';

\*((new\_element->value\_as\_string)+2)='**\0**';

new\_element->behind=NULL;

new\_element->variable\_name=malloc(strlen(variable\_name)+1);

strcpy(new\_element->variable\_name, variable\_name);

if(\*list\_of\_variables==NULL) //If list is empty.

\*list\_of\_variables=new\_element;

else

{

//Now the new element is the head of the list.

new\_element->behind=\*list\_of\_variables;

\*list\_of\_variables=new\_element;

}

}

int **variableExists**(struct Memory \*list\_of\_variables, char \*variable\_name)

{

/\* The entire linked list will be traversed looking for a stored variable

with the same name as the required name. \*/

if(list\_of\_variables == NULL)

return 0;

struct Memory \*reader=list\_of\_variables;

while((reader->behind)!=NULL)

{

if(strcmp(reader->variable\_name, variable\_name)==0)

return 1;

reader=reader->behind;

}

//Last possible element of the linked list.

if(strcmp(reader->variable\_name, variable\_name)==0)

return 1;

return 0;

}

18





2.c Outs

For the outputs a structure will be used such that it can store the elements that are going to be

printed, remember that there are two elements that can be printed, also remember that C does not

have generic data types, for this a variable will be used that tells us if the saved element is a string or

an array of characters, to save the referred element a void type pointer will be used.

2.c.1 Code

struct OutList

{

void \*element\_of\_outlist;

int element\_code; //0-string, 1-char array

struct OutList \*next\_element\_of\_outlist;

};

struct OutList \*out\_list; //Global variable.

void **addStringElementToOutList**(struct StringStructure \*\*character\_list,

struct OutList \*\*out\_list)

{

struct StringStructure \*string;

string=malloc(sizeof(struct StringStructure));

string=\*character\_list;

\*character\_list=NULL;

struct OutList \*element;

element=malloc(sizeof(struct OutList));

element->element\_of\_outlist=string;

(\*element).element\_code=0;

element->next\_element\_of\_outlist=NULL;

if(\*out\_list==NULL) //If list is empty.

\*out\_list=element;

else

{

struct OutList \*reader;

reader=\*out\_list;

while (reader->next\_element\_of\_outlist != NULL)

reader = (reader)->next\_element\_of\_outlist;

((reader)->next\_element\_of\_outlist)=element;

}

}

void **printString**(struct StringStructure \*character\_list)

{

while(character\_list!=NULL) //Will reset at the same time!

{

19





printf(**"**%c**"**, (\*character\_list).character);

character\_list=character\_list->next;

}

}

void **printOutList**(struct OutList \*\*out\_list)

{

while (\*out\_list!=NULL)

{

if((\*out\_list)->element\_code==0)

{

struct StringStructure \*string;

string=(struct StringStructure \*)((\*out\_list)->element\_of\_outlist);

printString( string );

}

if((\*out\_list)->element\_code==1)

{

printf(**"**%s**"**, (char\*)((\*out\_list)->element\_of\_outlist));

}

\*out\_list = (\*out\_list)->next\_element\_of\_outlist;

}

}

void **addCharArrayToOutList**(char \*char\_array, struct OutList \*\*out\_list)

{

struct OutList \*new\_element;

new\_element=malloc(sizeof(struct OutList));

new\_element->element\_of\_outlist=malloc(103);

strcpy((new\_element->element\_of\_outlist), char\_array);

(\*new\_element).element\_code=1;

new\_element->next\_element\_of\_outlist=NULL;

if(\*out\_list==NULL) //If list is empty.

\*out\_list=new\_element;

else

{

struct OutList \*reader;

reader=\*out\_list;

while (reader->next\_element\_of\_outlist != NULL)

reader = (reader)->next\_element\_of\_outlist;

((reader)->next\_element\_of\_outlist)=new\_element;

}

}

void **addVariableToOutList**(char \*char\_array, struct OutList \*\*out\_list)

{

char \*number\_as\_char\_array;

number\_as\_char\_array=obtainVariableValue(char\_array);

addCharArrayToOutList(number\_as\_char\_array, out\_list);

}

void **addNewlineToOutList**(struct OutList \*\*out\_list)

{

char \*newline=malloc(2);

strcpy(newline, **"\n"**);

addCharArrayToOutList(newline, out\_list);

}

20





2.e Arithmetic Operations

In order to give the correct results of the arithmetic operations, it has been necessary to partition the

cases that may occur, which are the ones shown below.

Having noted these situations, the required algorithms have been designed by partitioning the

situations. Two functions have been made which will take two positive values, one for addition and

the other for subtraction. Two other functions have been made which will queue the values

obtained, when I say strain, I mean as if you wanted to add zero to a variable, or if you wanted to

subtract a negative number from a variable of positive value that would actually be making a sum,

straining the values will be sent to the necessary functions if necessary.

We must also remember that a problem arises in the subtractions because all the operations will be

done manually, for example, let's say that the user wants to subtract nine hundred and ninety-eight

to nine hundred and ninety-nine, when doing it manually we would obtain two zeros in the prefix

which would not be desired, this forces us to have to write a function which would eliminate the

unnecessary zeros from the numerical values, which will also help in reading the code, so if the user

enters unnecessary zeros in the code they will not be taken into account.

Also remember that the problem arises that the result of a sum exceeds one hundred digits, for that

reason, additionally this situation will also be controlled in the function of the sums.

21





2.e.1 Code

char \*natural\_number; //Global variable.

char \*variable\_name; //Global variable.

void **moveValue**(char \*variable\_name, char\* value)

{

struct Memory \*reader=memory;

while((reader->behind)!=NULL)

{

if(strcmp(reader->variable\_name, variable\_name)==0)

break;

else

reader=reader->behind;

}

strcpy(reader->value\_as\_string, value);

}

char \***obtainVariableValue**(char \*variable\_name)

{

struct Memory \*reader=memory;

while((reader->behind)!=NULL)

{

if(strcmp(reader->variable\_name, variable\_name)==0)

return reader->value\_as\_string;

reader=reader->behind;

}

return reader->value\_as\_string;

}

/\* The functions that fulfill the functions of adding and subtracting

will work evenly. Why? Look down.

ADD X TO Y - SUB X FROM Y

\*Sum

x=0 -> (y)

y=0 -> (x)

x>0 & y>0 -> +(add x to y)

x**<0 & y>**0 -> +(sub x from y)

x>0 & y**<0 ->** -(sub x from y)

x**<0 & y<0 ->** -(add x to y)

\*Sub

x=0 -> (y)

y=0 -> -(x)

\*x>0 & y>0

y>=x -> +(sub x from y)

x>y -> -(sub x from y)

x**<0 & y>**0 -> +(add x to y)

x>0 & y**<0 ->** -(add x to y)

\*x**<0 & y<0**

**y>**=x -> +(sub -y from -x)

x>y -> -(sub -y from -x)

\*/

char\* **doTheSum**(char\* value1, char\* value2, int line\_number)//Only for positives.

{

char \*result;

result=malloc(102); // \0 - 100 digit - \0

\*(result)='**\0**';

int x1, x2;

22





x1=0; x2=0;

for(;\*(value1+x1)!='**\0**'; x1++);

for(;\*(value2+x2)!='**\0**'; x2++);

x1-=1; x2-=1; //Going to the last digits indeces.

int cin, sum, x3;

cin=0; x3=-1;

for(;\*(value1+x1)!='**\0**' && \*(value2+x2)!='**\0**'; x1--, x2--, x3--)

{

sum=cin+((int)\*(value1+x1)-48)+((int)\*(value2+x2)-48);

if(sum<10)

{

sum+=48; //ascii

\*(result+x3)=sum;

cin=0;

}

else

{

cin=1;

sum=(sum%10)+48;

\*(result+x3)=sum;

}

}

for(;\*(value1+x1)!='**\0**';x1--, x3--)

{

sum=cin+((int)\*(value1+x1)-48);

if(sum<10)

{

sum+=48; //ascii

\*(result+x3)=sum;

cin=0;

}

else

{

cin=1;

sum=(sum%10)+48;

\*(result+x3)=sum;

}

}

for(;\*(value2+x2)!='**\0**';x2--, x3--)

{

sum=cin+((int)\*(value2+x2)-48);

if(sum<10)

{

sum+=48; //ascii

\*(result+x3)=sum;

cin=0;

}

else

{

cin=1;

sum=(sum%10)+48;

\*(result+x3)=sum;

}

}

if(cin)

{

if(x3==-101) //Exceding the digits

alertError(15, line\_number);

\*(result+x3)=49; //'1';

23





x3--;

}

\*(result+x3)='**\0**';

result=result+x3+1;

return result;

}

char\* **doTheSubtraction**(char\* value1, char\* value2);

int **whichNumberIsBigger**(char \*value0, char \*value1);

void **sumStringIntegerToVariable**(char \*variable\_name, char\* value,

int line\_number)

{

char \*variable\_value=malloc(103);

strcpy(variable\_value, obtainVariableValue(variable\_name));

if(\*variable\_value=='0')

{

moveValue(variable\_name, value);

return;

}

else if(\*value=='0')

return;

char\* result;

\*(variable\_value-1)='**\0**';

\*(value-1)='**\0**';

if(\*variable\_value!='-' && \*value!='-') //+ +

moveValue(variable\_name, doTheSum(variable\_value, value, line\_number));

else if(\*value=='-' && \*variable\_value=='-') // - -

{

\*(variable\_value++)='**\0**';

\*(value++)='**\0**';

result=doTheSum(variable\_value, value, line\_number);

\*(result-1)='-';

\*(result-2)='**\0**';

moveValue(variable\_name, --result);

}

else if(\*variable\_value=='-') //+ -

{

\*(variable\_value++)='**\0**';

if(whichNumberIsBigger(variable\_value, value))

{

result=doTheSubtraction(value, variable\_value);

moveValue(variable\_name, result);

}

else

{

result=doTheSubtraction(variable\_value, value);

\*(result-1)='-';

\*(result-2)='**\0**';

moveValue(variable\_name, --result);

}

}

else //- +

{

\*(value++)='**\0**';

24





if(whichNumberIsBigger(variable\_value, value))

{

result=doTheSubtraction(value, variable\_value);

\*(result-1)='-';

\*(result-2)='**\0**';

moveValue(variable\_name, --result);

}

else

{

result=doTheSubtraction(variable\_value, value);

moveValue(variable\_name, result);

}

}

}

/\* As we saw in the comment above, we will need this function for the

subtraction function. \*/

int **whichNumberIsBigger**(char \*value0, char \*value1) //Positive 2 numbers.

{

int x0, x1;

x0=strlen(value0); x1=strlen(value1);

if(x0>x1)

return 0;

else if(x0<x1)

return 1;

for(x0=0, x1=0; \*(value0+x0)!='**\0**'; x0++, x1++)

{

if((int)\*(value0+x0)>(int)\*(value1+x1)) //ascii

return 0;

else if((int)\*(value0+x0)<(int)\*(value1+x1)) //ascii

return 1;

}

return 0;

}

/\* The subtractions can leave unnecessary 0s, this function has been written

to eliminate them, it will also serve to eliminate unnecessary 0s found in

the code (example: 0005, -0033, etc ...). \*/

char\* **skipTheZeros**(char\* value)

{

int its\_negative=0;

if(\*value=='-')

{

value++;

its\_negative=1;

}

char\* advancer;

advancer=value;

int x=0;

for(;\*(advancer+x+1)=='0' && \*(advancer+x)=='0' ;x++);

if(\*(advancer+x+1)!='**\0**' && \*(advancer+x)=='0')

x++;

value=(advancer+x);

if(its\_negative && \*value!='0')

{

\*(value-1)='-';

25





\*(value-2)='**\0**';

value--;

}

else

\*(value-1)='**\0**';

return value;

}

char\* **doTheSubtraction**(char\* value1, char\* value2) //value1>=value2

{

char \*result;

result=malloc(103);

\*(result)='**\0**';

int x1, x2;

x1=0; x2=0;

for(;\*(value1+x1)!='**\0**'; x1++);

for(;\*(value2+x2)!='**\0**'; x2++);

x1-=1; x2-=1;

int cin, rest, x3;

cin=0; x3=-1;

for(;\*(value1+x1)!='**\0**' && \*(value2+x2)!='**\0**'; x1--, x2--, x3--)

{

rest=((int)\*(value1+x1)-48)-((int)\*(value2+x2)-48)-cin;

if(rest>=0)

{

rest+=48; //ascii

\*(result+x3)=rest;

cin=0;

}

else

{

cin=1;

rest=(rest+10)+48;

\*(result+x3)=rest;

}

}

for(;\*(value1+x1)!='**\0**';x1--, x3--)

{

rest=((int)\*(value1+x1)-48)-cin;

if(rest>=0)

{

rest+=48; //ascii

\*(result+x3)=rest;

cin=0;

}

else

{

cin=1;

rest=(rest+10)+48;

\*(result+x3)=rest;

}

}

for(;\*(value2+x2)!='**\0**';x2--, x3--)

{

rest=((int)\*(value2+x2)-48)-cin;

if(rest>=0)

{

rest+=48; //ascii

\*(result+x3)=rest;

cin=0;

26





}

else

{

cin=1;

rest=(rest+10)+48;

\*(result+x3)=rest;

}

}

\*(result+x3)='**\0**';

result=result+x3+1;

return skipTheZeros(result);

}

void **subtractStringIntegerToVariable**(char \*variable\_name, char\* value,

int line\_number)

{

char \*variable\_value;

variable\_value=obtainVariableValue(variable\_name);

if(\*variable\_value=='0')

{

if(\*value!='-')

{

\*(value-1)='-';

\*(value-2)='**\0**';

moveValue(variable\_name, --value);

return;

}

else

{

\*value='**\0**';

moveValue(variable\_name, ++value);

return;

}

}

else if(\*value==0)

return;

char \*result;

\*(variable\_value-1)='**\0**';

\*(value-1)='**\0**';

if(\*variable\_value!='-' && \*value!='-') //+ +

{

//Bigger-lowest values control to flip the result sign

if(whichNumberIsBigger(variable\_value, value))

{

result=doTheSubtraction(value, variable\_value);

\*(result-1)='-';

\*(result-2)='**\0**';

moveValue(variable\_name, --result);

}

else

{

result=doTheSubtraction(variable\_value, value);

moveValue(variable\_name, result);

}

}

else if(\*value=='-')

{

if(\*variable\_value=='-') // - -

27





{

\*(variable\_value++)='**\0**';

\*(value++)='**\0**';

if(whichNumberIsBigger(variable\_value, value))

{

result=doTheSubtraction(value, variable\_value);

moveValue(variable\_name, result);

}

else

{

result=doTheSubtraction(variable\_value, value);

\*(result-1)='-';

\*(result-2)='**\0**';

moveValue(variable\_name, --result);

}

}

else //- +

{

\*(value++)='**\0**';

result=doTheSum(value, variable\_value, line\_number);

moveValue(variable\_name, result);

}

}

else //+ -

{

\*(variable\_value++)='**\0**';

result=doTheSum(value, variable\_value, line\_number);

\*(result-1)='-';

\*(result-2)='**\0**';

moveValue(variable\_name, --result);

}

}

28





2.f Execution of Blocks

The same code that was used in the lexical analyzer will be used to execute the main blocks with the

only difference that an .xl document will not be written and it will also be taken into account when a

loop instruction has been read, in order to send it to a function written especially for loops that takes

into account from one-line loops to nested loops.

The design of the function that will execute the loops has been done in the style of unit tests, writing

tests of all possible situations and correcting the code based on errors.

I would also like to emphasize that if a negative or zero value is given for a loop, the program will also

analyze the code, only without yielding results of operations or outs.

The values of the loops will always be subtracted one at the end of the instruction, after the

subtraction if the value is not equivalent to zero (when we speak of positive values at the beginning)

the code will be executed again from the beginning of the point that it started.

29





2.f.1 Code

/\*--------------------- Analyze and Execute Code Blocks ------------------------

In order to make the interpreter as correct as possible, it has been decided to

design 2 different types of readings for the main block and a loop block.

Being an interpreter the program must read the lines of code one by one and at

the same time execute them one by one, this in the main block does not generate

a problem but in a loop block it does, that is why a function has been made

especially for loops such that if the value of a loop is positive it will read

and execute each line and if the value of the loop is equal to or less than 0

it will ONLY READ AND CONTROL the lines of code that the loop contains. If the

value of the loop is positive at the end of the loop, the program will subtract

one from the value and control if it is equivalent to 0, if it is equivalent to

0 the program will end and if not it will return to the reading of the line of

code whichever is the first within the loop you are working with.

When designing this function, all kinds of nested or nested loops that may

occur have also been taken into account. \*/

void **runLoopBlock**(FILE \*document\_to\_be\_read, int \*previous\_state,

int \*line\_number, char \*loop\_value\_variable, char \*loop\_value,

int is\_previous\_loop\_working)

{

int is\_loop\_value\_a\_constant=(loop\_value\_variable==NULL)?1:0;

int initial\_index\_of\_file=ftell(document\_to\_be\_read);

int initial\_line\_number=\*line\_number;

int is\_there\_a\_bracket=0;

char\* loop\_counter=malloc(102);

char\* one\_value=malloc(3);

strcpy(one\_value, **"**1**\0"**);

char character\_that\_is\_being\_read;

char character\_accumulation[102];

int saved\_string\_code;

int current\_index\_counter=0;

int comment\_flag=0;

int string\_constant\_flag=0;

int type\_of\_space\_flag=0; //Reader speed booster.

if(!is\_loop\_value\_a\_constant)

strcpy(loop\_counter, obtainVariableValue(loop\_value\_variable));

else

strcpy(loop\_counter, loop\_value);

if(\*loop\_counter=='0' || \*loop\_counter=='-')

is\_previous\_loop\_working=0;

while((character\_that\_is\_being\_read = fgetc(document\_to\_be\_read)) != EOF)

{

if( (isAlphaChar(character\_that\_is\_being\_read) ||

isConstantChar(character\_that\_is\_being\_read) ||

character\_that\_is\_being\_read=='\_' ||

character\_that\_is\_being\_read=='-')

&& !comment\_flag && !string\_constant\_flag)

{

if(current\_index\_counter<101)

{

character\_accumulation[current\_index\_counter++]=

character\_that\_is\_being\_read;

type\_of\_space\_flag=0;

30





}

else

{

character\_accumulation[current\_index\_counter++]='**\0**';

strcpy(character\_accumulation,

skipTheZeros(character\_accumulation));

current\_index\_counter=strlen(character\_accumulation);

if((current\_index\_counter+1)< 101) //plus actual character

{

character\_accumulation[current\_index\_counter++]=

character\_that\_is\_being\_read;

continue;

}

alertErrorPerState(\*line\_number, previous\_state);

}

}

else if(string\_constant\_flag && character\_that\_is\_being\_read!='"')

{

addCharToString(&string, character\_that\_is\_being\_read);

if(character\_that\_is\_being\_read=='**\n**')

\*line\_number=(\*line\_number)+1;

continue;

}

else if(comment\_flag && character\_that\_is\_being\_read!='}')

{

if(character\_that\_is\_being\_read=='**\n**')

\*line\_number=(\*line\_number)+1;

continue;

}

else if(isPauseChar(character\_that\_is\_being\_read))

{

character\_accumulation[current\_index\_counter++]='**\0**';

saved\_string\_code=encodeSavedString(character\_accumulation);

if(saved\_string\_code==5) //valid integer

strcpy(character\_accumulation,

skipTheZeros(character\_accumulation));

if((character\_that\_is\_being\_read==' ' ||

character\_that\_is\_being\_read=='**\t**' ||

character\_that\_is\_being\_read=='**\n**' ) &&

!type\_of\_space\_flag)

{

type\_of\_space\_flag=1;

typeOfSpacePositionAndTransitionMaker(previous\_state,

saved\_string\_code, character\_accumulation, \*line\_number);

if(strcmp(character\_accumulation, **"**times**"**)==0)

{

runLoopBlock(document\_to\_be\_read, previous\_state,

line\_number, variable\_name, natural\_number,

is\_previous\_loop\_working);

//For nested loop.

if(\*previous\_state==0 && !is\_there\_a\_bracket)

{

if(is\_previous\_loop\_working)

{

31





if(is\_loop\_value\_a\_constant)

strcpy(loop\_counter,

doTheSubtraction(loop\_counter, one\_value));

else

{

subtractStringIntegerToVariable(

loop\_value\_variable, one\_value,

\*line\_number);

strcpy(loop\_counter,

obtainVariableValue(loop\_value\_variable));

}

if(\*loop\_counter=='0' || \*loop\_counter=='-')

{

previous\_state=0;

return;

}

fseek(document\_to\_be\_read, initial\_index\_of\_file,

SEEK\_SET);

is\_there\_a\_bracket=0;

\*previous\_state=9;

is\_there\_a\_bracket=0;

\*line\_number=initial\_line\_number;

}

else

return; //End of loop.

}

}

if(character\_that\_is\_being\_read=='**\n**')

\*line\_number=(\*line\_number)+1;

}

else if(character\_that\_is\_being\_read==',')

commaPosition(previous\_state, saved\_string\_code,

character\_accumulation, \*line\_number);

else if(character\_that\_is\_being\_read=='[')

{

character\_accumulation[current\_index\_counter++]='**\0**';

saved\_string\_code=encodeSavedString(character\_accumulation);

typeOfSpacePositionAndTransitionMaker(previous\_state,

saved\_string\_code, character\_accumulation, \*line\_number);

if(\*previous\_state==9)

{

if(saved\_string\_code==17) //Empty code.

{

if(!is\_there\_a\_bracket)

{

\*previous\_state=0;

is\_there\_a\_bracket=1;

}

else

alertError(13, \*line\_number);

}

else // 'times[' case

{

fseek(document\_to\_be\_read, ftell(document\_to\_be\_read)-1,

SEEK\_SET);

runLoopBlock(document\_to\_be\_read, previous\_state,

32





line\_number, variable\_name,

natural\_number, is\_previous\_loop\_working);

//For nested loop.

if(\*previous\_state==0 && !is\_there\_a\_bracket)

{

if(is\_previous\_loop\_working)

{

if(is\_loop\_value\_a\_constant)

strcpy(loop\_counter,

doTheSubtraction(loop\_counter, one\_value));

else

{

subtractStringIntegerToVariable(

loop\_value\_variable, one\_value,

\*line\_number);

strcpy(loop\_counter,

obtainVariableValue(loop\_value\_variable));

}

if(\*loop\_counter=='0' || \*loop\_counter=='-')

{

previous\_state=0;

return;

}

fseek(document\_to\_be\_read,initial\_index\_of\_file,

SEEK\_SET);

is\_there\_a\_bracket=0;

\*previous\_state=9;

is\_there\_a\_bracket=0;

\*line\_number=initial\_line\_number;

}

else

return; //End of loop.

}

}

}

else

alertErrorPerState(\*line\_number, previous\_state);

}

else if(character\_that\_is\_being\_read==']' )

{

if(is\_there\_a\_bracket && \*previous\_state==0)

{

if(is\_previous\_loop\_working)

{

if(is\_loop\_value\_a\_constant)

strcpy(loop\_counter, doTheSubtraction(loop\_counter,

one\_value));

else

{

subtractStringIntegerToVariable(loop\_value\_variable,

one\_value, \*line\_number);

strcpy(loop\_counter,

obtainVariableValue(loop\_value\_variable));

}

if(\*loop\_counter=='0' || \*loop\_counter=='-')

{

\*previous\_state=0;

return;

33





}

fseek(document\_to\_be\_read, initial\_index\_of\_file,

SEEK\_SET);

is\_there\_a\_bracket=0;

\*previous\_state=9;

\*line\_number=initial\_line\_number;

}

else

return; //End of loop.

}

else

alertError(13, \*line\_number);

}

else if(character\_that\_is\_being\_read=='.')

{

dotPosition(previous\_state, saved\_string\_code,

character\_accumulation, \*line\_number,

is\_previous\_loop\_working);

if(!is\_there\_a\_bracket)

{

if(is\_previous\_loop\_working)

{

if(is\_loop\_value\_a\_constant)

strcpy(loop\_counter, doTheSubtraction(loop\_counter,

one\_value));

else

{

subtractStringIntegerToVariable(loop\_value\_variable,

one\_value, \*line\_number);

strcpy(loop\_counter,

obtainVariableValue(loop\_value\_variable));

}

if(\*loop\_counter=='0' || \*loop\_counter=='-')

{

\*previous\_state=0;

return;

}

fseek(document\_to\_be\_read, initial\_index\_of\_file,

SEEK\_SET );

\*line\_number=initial\_line\_number;

}

else

return;

}

}

character\_accumulation[0]=0; //Reset.

current\_index\_counter=0; //Reset.

}

else

{

type\_of\_space\_flag=0; //Reset.

if(character\_that\_is\_being\_read==13)

continue;

else if(character\_that\_is\_being\_read=='{')

34





{

character\_accumulation[current\_index\_counter++]='**\0**';

current\_index\_counter=0;

saved\_string\_code=encodeSavedString(character\_accumulation);

if(saved\_string\_code==5) //valid integer

strcpy(character\_accumulation,

skipTheZeros(character\_accumulation));

typeOfSpacePositionAndTransitionMaker(previous\_state,

saved\_string\_code, character\_accumulation, \*line\_number);

comment\_flag=1;

}

else if(character\_that\_is\_being\_read=='"')

{

character\_accumulation[current\_index\_counter++]='**\0**';

saved\_string\_code=encodeSavedString(character\_accumulation);

typeOfSpacePositionAndTransitionMaker(previous\_state,

saved\_string\_code, character\_accumulation, \*line\_number);

current\_index\_counter=0;

stringCharacterPosition(&string\_constant\_flag, previous\_state,

\*line\_number);

if(string\_constant\_flag)

{

character\_accumulation[current\_index\_counter++]='**\0**';

saved\_string\_code=encodeSavedString(character\_accumulation);

typeOfSpacePositionAndTransitionMaker(previous\_state,

saved\_string\_code, character\_accumulation, \*line\_number);

character\_accumulation[0]=0; //Reset.

current\_index\_counter=0; //Reset.

}

else

{

saved\_string\_code=16;

typeOfSpacePositionAndTransitionMaker(previous\_state,

saved\_string\_code, character\_accumulation, \*line\_number);

character\_accumulation[0]=0; //Reset.

current\_index\_counter=0; //Reset.

}

}

else if(character\_that\_is\_being\_read=='}')

{

if (!comment\_flag)

alertErrorPerState(\*line\_number, previous\_state);

comment\_flag=0;

}

else //Unrecognized character

alertError(14, \*line\_number);

}

}

/\* Control if at the end of the document something remained in the variable

that saves the characters. \*/

if(character\_accumulation[current\_index\_counter-1]!='**\0**')

{

character\_accumulation[current\_index\_counter++]='**\0**';

35





saved\_string\_code=encodeSavedString(character\_accumulation);

typeOfSpacePositionAndTransitionMaker(previous\_state,

saved\_string\_code, character\_accumulation, \*line\_number);

saved\_string\_code=encodeSavedString(character\_accumulation);

/\* Here we will check if the double quotation marks or curly brackets

were closed. \*/

endOfLine(previous\_state, string\_constant\_flag,

comment\_flag, is\_there\_a\_bracket);

}

}

int **isLoopValuePositive**()

{

if(variable\_name==NULL)

{

if(\*natural\_number!='0' && \*natural\_number!='-')

return 1;

return 0;

}

char \*value\_of\_variable=obtainVariableValue(variable\_name);

if(\*value\_of\_variable!='0' && \*value\_of\_variable!='-')

return 1;

return 0;

}

void **runMainCodeBlock**(char\* document\_name\_to\_be\_read)

{

FILE \*document\_to\_be\_read;

if ((document\_to\_be\_read = fopen(document\_name\_to\_be\_read, **"**r**"**)) == NULL)

alertError(2, -1);

char character\_that\_is\_being\_read;

memory=NULL;

char character\_accumulation[103];

int previous\_state=0; //Initial.

int saved\_string\_code;

int line\_number=1;

int current\_index\_counter=0; /\* It will be used to be able to save the

temporary string linearly \*/

int comment\_flag=0;

int string\_constant\_flag=0;

int square\_bracket\_counter=0;

int type\_of\_space\_flag=0; //Reader speed booster.

while((character\_that\_is\_being\_read = fgetc(document\_to\_be\_read)) != EOF)

{

if( (isAlphaChar(character\_that\_is\_being\_read) ||

isConstantChar(character\_that\_is\_being\_read) ||

character\_that\_is\_being\_read=='\_' ||

character\_that\_is\_being\_read=='-')

&& !comment\_flag && !string\_constant\_flag)

{

if(current\_index\_counter<101)

{

character\_accumulation[current\_index\_counter++]=

36





character\_that\_is\_being\_read;

type\_of\_space\_flag=0;

}

else

{

character\_accumulation[current\_index\_counter++]='**\0**';

strcpy(character\_accumulation,

skipTheZeros(character\_accumulation));

current\_index\_counter=strlen(character\_accumulation);

if((current\_index\_counter+1)< 101) //plus actual character

{

character\_accumulation[current\_index\_counter++]=

character\_that\_is\_being\_read;

continue;

}

alertErrorPerState(line\_number, &previous\_state);

}

}

else if(string\_constant\_flag && character\_that\_is\_being\_read!='"')

{

addCharToString(&string, character\_that\_is\_being\_read);

if(character\_that\_is\_being\_read=='**\n**')

line\_number++;

continue;

}

else if(comment\_flag && character\_that\_is\_being\_read!='}')

{

if(character\_that\_is\_being\_read=='**\n**')

line\_number++;

continue;

}

else if(isPauseChar(character\_that\_is\_being\_read))

{

character\_accumulation[current\_index\_counter++]='**\0**';

saved\_string\_code=encodeSavedString(character\_accumulation);

if(saved\_string\_code==5) //valid integer

strcpy(character\_accumulation,

skipTheZeros(character\_accumulation));

if((character\_that\_is\_being\_read==' ' ||

character\_that\_is\_being\_read=='**\t**' ||

character\_that\_is\_being\_read=='**\n**' )&&

!type\_of\_space\_flag)

{

type\_of\_space\_flag=1;

typeOfSpacePositionAndTransitionMaker(&previous\_state,

saved\_string\_code, character\_accumulation, line\_number);

if(strcmp(character\_accumulation, **"**times**"**)==0)

{

runLoopBlock(document\_to\_be\_read, &previous\_state,

&line\_number, variable\_name, natural\_number,

isLoopValuePositive());

}

37





if(character\_that\_is\_being\_read=='**\n**')

line\_number++;

}

else if(character\_that\_is\_being\_read==',')

commaPosition(&previous\_state,

saved\_string\_code, character\_accumulation, line\_number);

else if(character\_that\_is\_being\_read=='[')

{

character\_accumulation[current\_index\_counter++]='**\0**';

saved\_string\_code=encodeSavedString(character\_accumulation);

typeOfSpacePositionAndTransitionMaker(&previous\_state,

saved\_string\_code, character\_accumulation, line\_number);

if(previous\_state==9)

{

fseek(document\_to\_be\_read, ftell(document\_to\_be\_read)-1,

SEEK\_SET);

runLoopBlock(document\_to\_be\_read, &previous\_state,

&line\_number, variable\_name, natural\_number,

isLoopValuePositive());

}

else

alertErrorPerState(line\_number, &previous\_state);

}

else if(character\_that\_is\_being\_read==']' )

alertError(13, line\_number);

else if(character\_that\_is\_being\_read=='.')

dotPosition(&previous\_state,

saved\_string\_code, character\_accumulation, line\_number, 1);

character\_accumulation[0]=0; //Reset.

current\_index\_counter=0; //Reset.

}

else

{

type\_of\_space\_flag=0; //Reset.

if(character\_that\_is\_being\_read==13)

continue;

else if(character\_that\_is\_being\_read=='{')

{

character\_accumulation[current\_index\_counter++]='**\0**';

current\_index\_counter=0;

saved\_string\_code=encodeSavedString(character\_accumulation);

typeOfSpacePositionAndTransitionMaker(&previous\_state,

saved\_string\_code, character\_accumulation, line\_number);

if(previous\_state==9)

{

fseek(document\_to\_be\_read, ftell(document\_to\_be\_read)-1,

SEEK\_SET);

runLoopBlock(document\_to\_be\_read, &previous\_state,

&line\_number, variable\_name, natural\_number,

isLoopValuePositive());

}

comment\_flag=1;

38





}

else if(character\_that\_is\_being\_read=='"')

{

character\_accumulation[current\_index\_counter++]='**\0**';

saved\_string\_code=encodeSavedString(character\_accumulation);

typeOfSpacePositionAndTransitionMaker(&previous\_state,

saved\_string\_code, character\_accumulation, line\_number);

current\_index\_counter=0;

stringCharacterPosition(&string\_constant\_flag, &previous\_state,

line\_number);

if(string\_constant\_flag)

{

character\_accumulation[current\_index\_counter++]='**\0**';

saved\_string\_code=encodeSavedString(character\_accumulation);

typeOfSpacePositionAndTransitionMaker(&previous\_state,

saved\_string\_code, character\_accumulation, line\_number);

character\_accumulation[0]=0; //Reset.

current\_index\_counter=0; //Reset.

}

else

{

saved\_string\_code=16;

typeOfSpacePositionAndTransitionMaker(&previous\_state,

saved\_string\_code, character\_accumulation, line\_number);

character\_accumulation[0]=0; //Reset.

current\_index\_counter=0; //Reset.

}

}

else if(character\_that\_is\_being\_read=='}')

{

if (!comment\_flag)

alertErrorPerState(line\_number, &previous\_state);

comment\_flag=0;

}

else //Unrecognized character

alertError(14, line\_number);

}

}

if(character\_accumulation[current\_index\_counter-1]!='**\0**')

{

character\_accumulation[current\_index\_counter++]='**\0**';

saved\_string\_code=encodeSavedString(character\_accumulation);

typeOfSpacePositionAndTransitionMaker(&previous\_state,

saved\_string\_code, character\_accumulation, line\_number);

saved\_string\_code=encodeSavedString(character\_accumulation);

/\*Here we will check if the double quotation marks or curly brackets were

closed. \*/

endOfLine(&previous\_state, string\_constant\_flag, comment\_flag, 0);

}

fclose(document\_to\_be\_read);

}

39





\3) USER INPUTS & INTERPRETER IMPLEMENTATION

Now only the name of the file that you want to execute will be taken, for each program execution

only one script will be able to be executed.

As in the previous project, file names of any length can be taken.

3.a Code

/\*----------------------------- User Inputs ------------------------------------

It will only be taken in the name of the document that the user wants to

execute, the length of the name does not matter, you can write names of any

length. \*/

int document\_name\_length; //Global variable.

char \*document\_name; //Global variable.

void **get\_command\_of\_read\_file**(FILE\* fp)

{

document\_name\_length=25; //Standart length, can change.

//Allocating the requested memory.

document\_name = realloc(NULL, sizeof(\*document\_name)\*document\_name\_length);

char character\_of\_input='**\n**';

while(EOF!=(character\_of\_input=fgetc(fp)) &&

character\_of\_input==' ' || character\_of\_input=='**\t**' )

continue;

if(character\_of\_input=='**\n**')

//CAMBİARRRRRRRRR

{

\*document\_name='.';

\*(document\_name+1)='b';

\*(document\_name+2)='a';

\*(document\_name+3)='**\0**';

return;

}

int index=0;

\*(document\_name+index++)=character\_of\_input; //First letter getted up.

while(EOF!=(character\_of\_input=fgetc(fp)) && character\_of\_input != '**\n**')

{

/\* Here the characters belonging to the entered file name will be

saved.

If any errors occurred due to the realloc function the user would be

notified and the program would start over.\*/

\*(document\_name+index++)=character\_of\_input;

if(index==document\_name\_length)

{

document\_name =

realloc(document\_name,

sizeof(\*document\_name)\*(document\_name\_length+=16));

if(!document\_name\_length)

{

printf(**"\033**[0;31m**"**); //Set the text to the color red.

printf(**"**An error ocurred, press any key to end the program...**\n"**);

getchar();

40





exit(0);

}

}

}

index+=3; //For the extensions.

document\_name\_length=index; //It increased one up.

document\_name=realloc(document\_name,

sizeof(\*document\_name)\*index);

/\* If any errors occurred due to the realloc function the user would be

notified and the program would start over.\*/

if(!document\_name)

{

printf(**"\033**[0;31m**"**); //Set the text to the color red.

printf(**"**An error ocurred, press any key to end the program...**\n"**);

getchar();

exit(0);

}

\*(document\_name+index-3)='.';

\*(document\_name+index-2)='b';

\*(document\_name+index-1)='a';

\*(document\_name+index)='**\0**';

/\* We know that C always reserves an index at the end for a string

end, just in case we will always end character arrays. \*/

return;

}

int **main**(int argc, char\*\* argv)

{

printf(**"**Source file name to be read: **"**);

get\_command\_of\_read\_file(stdin);

printf(**"\n"**);

printf(**"\033**[0;32m**"**); //Set the text to the color green.

/\* The name of the document is sent to our function that acts as a

lexical analyzer \*/

runMainCodeBlock(document\_name);

printf(**"\033**[0m**"**); //Resets the text to default color.

printf(**"\n**Completed process! Press any key to end the program!**\n"**);

getchar();

return (EXIT\_SUCCESS);

}

41





\4) Test Screenshots

4.a Finding the nth Fibonacci of 101 Digits

.

.

.

.

.

.

.

.

.

.

.

.

42





4.b Finding The Sum of The Consecutive Numbers Squared

43





4.c Drawing a Right-Angled Triangle

44





4.d Syntax Error Example 1

4.e Syntax Error Example 2

45

